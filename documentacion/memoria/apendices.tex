\appendix
\chapter{Patrones de diseño utilizados}

\section{MVC}
Este patrón permite una clara separación entre la vista de una aplicación web y su modelo correspondiente, gracias a un controlador que los mantiene desacoplados en todo momento, de modo que no necesiten conocer la naturaleza el uno del otro.

\begin{itemize}
\item \textbf{Modelo:} Esta es la representación específica de la información con la cual el sistema opera. La lógica de datos asegura la integridad de estos y permite derivar nuevos datos.
\item \textbf{Vista:} Este presenta el modelo en un formato adecuado para interactuar, usualmente la interfaz de usuario.
\item \textbf{Controlador:} Este responde a eventos, usualmente acciones del usuario e invoca cambios en el modelo y probablemente en la vista.
\end{itemize}

\section{Transfer Object} 
Este patrón sirve para agrupar un conjunto de atributos procedentes de uno o varios objetos del dominio y es aplicable en el caso de que necesitemos representar un conjunto de atributos procedentes de uno o varios objetos del dominio.

Cualquier componente que sigue este patrón ofrece getters \footnote{métodos para obtener el valor de un atributo} y/o setters \footnote{métodos que permiten asignar el valor a un atributo} para acceder y/o establecer a los atributos.

\section{Data Access Object}
El principal objetivo de este patrón es desacoplar la lógica de negocio de la lógica de acceso a datos, de manera que se pueda sustituir la fuente de datos fácilmente. De esta manera, usando este patrón podremos seleccionar el tipo de fuente de datos durante la instalación o configuración de una aplicación.

\section{Facade}
El patrón facade (o fachada) sirve para proveer de una interfaz unificada y sencilla que haga de intermediaria entre el cliente y un interfaz o conjunto de interfaces más complejas. Esto basicamente consigue una independencia del código que la usa.

En nuestro sistema, nos permite poder cambiar el código de acceso a datos sin tener que variar por ello la parte de código del modelo que sirve las funcionalidades al controlador.

\section{Business delegate}
El objetivo de este patrón es facilitar a la capa cliente ocultando las tecnologías utilizadas en el modelo. Este patrón es utilizado cuando se quiere proporcionar una capa de acceso al modelo que oculte la tecnología usada en su implementación.
Las ventajas que proporciona el uso de este patrón:
\begin{itemize}
	\item Mellora o mantemento.
	\item Permite separación de roles: creadores da capa cliente e creadores da capa modelo.
	\item Pode proporcionar caché para mellorar a eficiencia.
\end{itemize}

\section{Decorador}
Este patrón permite añadir responsabilidades a un objeto dinámicamente, proporcionando una alternativa flexible a la extensión de una clase, es decir, se sirven de la herencia para extender sus responsabilidades.

Mediante la aplicación de este patrón se consigue:
\begin{itemize}
	\item Añadir responsabilidades a objetos de manera dinámica y transparente.
	\item Para suprimir responsabilidades de los objetos.
	\item Cuando no es práctico el uso de la herencia.
\end{itemize}

\section{Factoria abstracta}
Este patrón utiliza una interfaz para la creación de familias de objetos relacionados sin especificar sus clases concretas, muy utilizado para proporcionar múltiples look-and-feels mediante la definición de un juego de componentes.

La aplicabilidad de este patrón radica en:
\begin{itemize}
	\item Un sistema debe ser independiente de la forma en que sus productos son creados y representados.
	\item Un sistema debe ser configurado con una de muchas familias de productos disponibles.
	\item Una familia de productos son diseñados para su uso conjunto, y se requiere asegurar este uso conjunto
	\item Se desea proporcionar una biblioteca de productos presentando su interfaz, pero no su implementación
\end{itemize}

\section{Singleton}
El patrón singleton (o instancia única) se utiliza cuando es necesario asegurarse de que una clase tiene sólo una instancia y se quiere proporcionar un punto global de acceso a ella.

Este patrón está compuesto por una clase que define como privado su constructor, con el fin de evitar la creación de nuevos objetos, e incluye un atributo de clase privado que se usa para alojar la instancia única y un método que permite el acceso a dicha instancia.

\section{Command}
El patrón Command (Comando) encapsula una petición como un objeto, de modo que permite la parametrización de clientes con diferentes peticiones, crear colas de peticiones y soporte de operaciones cancelables (undo).

La aplicabilidad de este patrón radica en:
\begin{itemize}
	\item Establecer como parámetro de un objeto la acción a realizar.
	\item Especificar, encolar, y ejecutar peticiones en diferentes momentos.
	\item Soporte de Deshacer.
	\item Soporte de Logging
	\item Soporte de Transacciones
\end{itemize}

\section{Chain of Responsability}
El patrón Chain of Responsability (Cadena de responsabilidad) permite la posibilidad de gestionar una petición a más de un objeto mediante el encadenamiento de receptores desacoplando el emisor de la petición de los receptores (receptor implícito). Se establece una cadena de objetos que delegan la petición
hasta que uno se hace cargo.

Veamos su diversas aplicaciones:
\begin{itemize}
	\item Más de un objeto puede manejar una petición, y no se conoce a priori cual de ellos.
	\item No se desea identificar explícitamente el receptor de una petición.
	\item Los objetos que pueden manejar la petición varían dinámicamente.
\end{itemize}

\section{Template}
El patrón Plantilla define el esqueleto de un algoritmo en una operación, pero difiere algunos pasos a las subclases, con el objetivo de implementar un método que difiera en otros métodos abstractos las partes del algoritmo que no se conocen o que son específicas. En otras palabras, es un método que define un algoritmo en base a una serie de operaciones abstractas que son redefinidas por las subclases para obtener un comportamiento concreto.

La aplicabilidad de este patrón es:
\begin{itemize}
	\item Implementar las partes invariables de un algoritmo una única vez y permitir que las subclases definan el comportamiento que cambia.
	\item Factorización de comportamiento común de las subclases en la superclase (evitar replicación de código mediante generalización)
	\item Para controlar la extensiones de las subclases. 
\end{itemize}

\chapter{Manuales}
\section{Manual de instalación}
\section{Manual de modificación de interfaces}
Una de las grandes ventajas que presenta Tapestry 5 radica en la posibilidad de realizar diseño de la interfaz sin necesidad de tener conocimiento de como se implementa un markup. Esto permite que un diseñador gráfico con conocimientos de html puro sea capaz de realizar cambios a su gusto. En este apéndice se mostrará la forma de realizar estos cambios de manera sencilla, de modo que sirva a modo de manual para su modificación.
Antes de nada, cabe destacar que la modificaciones que se pueden realizar sobre la vista se pueden realizar de dos forma específicas:
\begin{itemize}
	\item Modificando el CSS asociado a las diferentes páginas, pero que obliga a que la estructura de la vista no sea modificable.
	\item Modificando las plantillas o tml asociados a cada página dentro de la implementación, lo cuál si permite modificar la estructura de la vista.
\end{itemize}
Como el primer punto no supone ningun problema, ya que sólo se necesita modificar el fichero css determinado, no vamos a centra en como se puede modificar un tml.

\begin{figure}[htp]
\centering
\includegraphics*[width=15cm]{imagenes/votetml.png}
\caption{Ejemplo página tml}
\label{tml}
\end{figure}

En esta figura se muestran tres tipos de código representados en colores diferentes:
\begin{itemize}
	\item En negro se recoge el código html puro.
	\item En rojo se distingue el código perteneciente a componentes embebidos.
	\item En azul están los mensajes internacionalizados y los objetos inyectados dentro de la página.
\end{itemize}

Dentro de nuestro ejemplo podemos distinguir:
\begin{itemize}
	\item \textbf{Declaración de un espacio de nombres}
	{\tt \scriptsize
\begin{verbatim}
<html xmlns="http://www.w3.org/1999/xhtml"
xmlns:t="http://tapestry.apache.org/schema/tapestry_5_0_0.xsd">
\end{verbatim}
}
	\begin{itemize}
		\item Cualquier elemento o atributo que tenga prefijo t pertenece al
espacio de nombres de Tapestry
		\item En el markup generado, no se incluye la importacion del
espacio de nombres de Tapestry
	\end{itemize}
	\item \textbf{Componentes}
	
	Es posible incluir componentes dentro de una plantilla utilizando el elemento correspondiente (dentro del espacio de nombres de Tapestry).
{\tt \scriptsize
\begin{verbatim}
<t:if t:test="userSessionExists">
</t:if>
\end{verbatim}
}
	\item \textbf{Mensajes internacionalizados}
{\tt \scriptsize
\begin{verbatim}
<spam class="favourite" title="${message:markAsFavourite}" />
\end{verbatim}
}

	\textit{Message}: indica que valor es la clave de un mensaje del catálogo de mensajes. Dicho catálogo forma parte del soporte de internacionalizacion que proporciona Tapestry:
\begin{itemize}
	\item Permiten que los textos fijos de las plantillas, en lugar de escribirlos directamente en ellas, se escriban
en un fichero de mensajes
	\item Ficheros .properties
	\item Existe un catalogo de mensajes general para toda la aplicacion
	\item Es posible definir un fichero de mensajes específicos para una página
\end{itemize}
	\item \textbf{Objetos inyectados o propiedades}
	
	En el caso de acceso a propiedades es posible:	
\begin{itemize}
	\item Referirse a subpropiedades
	\item Invocar a un metodo del objeto que no sea un getter (utilizando parentesis a continuacion del
nombre del metodo)
\end{itemize}
\end{itemize}

Gracias a todo esto que se acaba de explicar, un diseñador podría modificar la estructura y la apariencia de la vista teniendo en cuenta que partes del código deben permanecer inalteradas y cuales son modificables, en este caso, el html puro dentro del \textit{tml}.
\chapter{Contenido del CD-ROM}

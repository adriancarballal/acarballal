\chapter{Diseño e implementación}
Tras la definición que se ha dado de la funcionalidad real que debe de cumplir el sistema, se detallarán las decisiones tomadas para el diseño e implementación del sistema. 

\section{Arquitectura}
Una vez que se realizó el estudio de las diferentes tecnologías disponibles en la actualidad se ha optado por una implementación utilizando una arquitectura MVC (Modelo-Vista-Controlador) mediante la integración de Hibernate y Spring para la capa modelo y el uso de Tapestry 5 en el caso de las capas vista y controlador.
\begin{figure}[h]
\centering
\includegraphics*[width=5cm]{imagenes/mvc.png}
\caption{Arquitectura MVC}
\label{MVC}
\end{figure}
\\
Para entender mejor este modelo arquitectónico veamos cada una de las partes en las que se divide:
\begin{itemize}
\item \textbf{Modelo:} Esta es la representación específica de la información con la cual el sistema opera. La lógica de datos asegura la integridad de estos y permite derivar nuevos datos.
\item \textbf{Vista:} Este presenta el modelo en un formato adecuado para interactuar, usualmente la interfaz de usuario.
\item \textbf{Controlador:} Este responde a eventos, usualmente acciones del usuario e invoca cambios en el modelo y probablemente en la vista.
\end{itemize}

El usuario interactúa con la interfaz de usuario de alguna forma. El controlador recibe la notificación de la acción solicitada por el usuario. El controlador gestiona el evento que llega y accede al modelo, posiblemente modificándolo de forma adecuada a la acción solicitada por el usuario. El controlador delega a los objetos de la vista la tarea de desplegar la interfaz de usuario. La vista obtiene sus datos del modelo para generar la interfaz apropiada para el usuario donde se refleja los cambios en el modelo.

\section{Estructura de paquetes}
\subsection{Paquete es.udc.acarballal.elmas.model}
En este paquete se implementa toda la lógica de negocio, separándola de otros aspectos, como es el caso de la vista y el controlador (ver Figura \ref{model}). A su vez implementa tanto los diferentes casos de uso recogidos en las tres fachadas (userservice, videoservice y adminservice) como el tratamento de las diferentes entidades participantes con su correspondiente persistencia.

\begin{figure}[htp]
\centering
\includegraphics{imagenes/model.jpg}
\caption{Estructura de paquetes de la capa modelo}
\label{model}
\end{figure}

Los paquetes en los que a su vez se subdivide son:
\begin{itemize}
	\item \textbf{es.udc.acarballal.elmas.model.userprofile:}	incluye las clases necesarias para mantener la persistencia de la entidad \textit{userprofile}, donde se recogen los datos referentes a la información de usuarios.
	\item \textbf{es.udc.acarballal.elmas.model.video:}	incluye las clases necesarias para mantener la persistencia de la entidad \textit{video}, donde se recogen los datos referentes a la información de videos.
	\item \textbf{es.udc.acarballal.elmas.model.vote:}	incluye las clases necesarias para mantener la persistencia de la entidad \textit{vote}, donde se recogen los votos de los diferentes videos.
	\item \textbf{es.udc.acarballal.elmas.model.message:}	incluye las clases necesarias para mantener la persistencia de la entidad \textit{message}, donde se recogen los mensajes enviados entre usuarios, en nuestro caso, mensajes de administradores a usuarios.
	\item \textbf{es.udc.acarballal.elmas.model.favourite:}	incluye las clases necesarias para mantener la persistencia de la entidad \textit{favourite}, donde se recogen las referencias a los videos favoritos de un determinado usuario.
	\item \textbf{es.udc.acarballal.elmas.model.usercomment:}	incluye las clases necesarias para mantener la persistencia de la entidad \textit{usercomment}, donde se recogen los comentario realizados sobre un determinado usuario.
	\item \textbf{es.udc.acarballal.elmas.model.videocomment:}	incluye las clases necesarias para mantener la persistencia de la entidad \textit{videocomment}, donde se recogen los comentarios realizados sobre un determinado video.
	\item \textbf{es.udc.acarballal.elmas.model.videocomplaint:}	incluye las clases necesarias para mantener la persistencia de la entidad \textit{videocomplaint}, donde se recogen las quejas realizadas sobre el contenido de un video.
	\item \textbf{es.udc.acarballal.elmas.model.usercommentcomplaint:}	incluye las clases necesarias para mantener la persistencia de la entidad \textit{usercommentcomplaint}, donde se recogen las quejas realizadas sobre el contenido de un comentario hacia un usuario.
	\item \textbf{es.udc.acarballal.elmas.model.videocommentcomplaint:}	incluye las clases necesarias para mantener la persistencia de la entidad \textit{videocommentcomplaint}, donde se recogen las quejas realizadas sobre el contenido de un comentario perteneciente a algún video.
	\item \textbf{es.udc.acarballal.elmas.model.userservice:}	incluye las interfaces y clases que implementan los casos
de uso relacionados con las entidades userprofile, message, usercomment y usercommentcomplaint.
\item \textbf{es.udc.acarballal.elmas.model.video:}	incluye las interfaces y clases que implementan los casos
de uso relacionados con las entidades video, vote, favourite, videocomment y videocommentcomplaint.
\item \textbf{es.udc.acarballal.elmas.model.adminservice:}	incluye las interfaces y clases que implementan los casos
de uso relacionados con la administración, manejando entidades como userprofile, video, message, videocomplaint, usercommentcomplaint, videocommentcomplaint.
\end{itemize}
Más adelante se profundizará en todos estos subpaquete en la sección \ref{capamodelo} denominada ``\titleref{capamodelo}'' (página \pageref{capamodelo}).
\subsection{Paquete es.udc.acarballal.elmas.web}
Este subpaquete implementa la lógica de la capa controlador, que se encargará de todos los aspectos de intercomunicación entre la vista (independientemente de que se trate de una aplicación web o aplicación cliente), y la lógica
de negocio del modelo.

\begin{figure}[htp]
\centering
\includegraphics{imagenes/web.jpg}
\caption{Estructura de paquetes de las capas vista y controlador}
\label{web}
\end{figure}

Los paquetes en los que a su vez se subdivide son:

\begin{itemize}
	\item \textbf{Paquete es.udc.acarballal.elmas.web.pages:} Contiene las clases asociadas con cada una de las páginas visibles para cualquier usuario. Las plantillas referentes a dichas páginas se encontrarán en el directorio \textit{resources} siguiendo una estructura de paquetes análoga.
	\item \textbf{Paquete es.udc.acarballal.elmas.web.pages.user:} Contiene las clases asociadas con cada una de las páginas visibles para un usuario re\-gis\-tra\-do. Las plantillas re\-fe\-ren\-tes a dichas páginas se encontrarán en el directorio \textit{resources} si\-guien\-do una estructura de paquetes análoga.
	\item \textbf{Paquete es.udc.acarballal.elmas.web.pages.admin:} Contiene las clases asociadas con cada una de las paginas visibles para un administrador. Las plantillas referentes a dichas páginas se encontrarán en el directorio \textit{resources} siguiendo una estructura de paquetes análoga.
	\item \textbf{Paquete es.udc.acarballal.elmas.web.pages.errors:} Contiene las clases asociadas con cada una de las paginas de error. Las plantillas referentes a dichas páginas se encontrarán en el directorio \textit{resources} siguiendo una estructura de paquetes análoga.
	\item \textbf{Paquete es.udc.acarballal.elmas.web.pages.mobile:}	Contiene las clases asociadas con cada una de las páginas visibles para cualquier usuario del servicio para dispositivos móviles. Las plantillas referentes a dichas páginas se encontrarán en el directorio \textit{resources} siguiendo una estructura de paquetes análoga.
	\item \textbf{Paquete es.udc.acarballal.elmas.web.pages.mobile.user:} Contiene las clases asociadas con cada una de las páginas visibles para un usuario registrado del servicio para dispositivos móviles. Las plantillas re\-fe\-ren\-tes a dichas páginas se encontrarán en el directorio \textit{resources} siguiendo una estructura de paquetes análoga.
	\item \textbf{Paquete es.udc.acarballal.elmas.web.pages.mobile.error:} Contiene las clases asociadas con cada una de las páginas de error del servicio para dispositivos móviles. Las plantillas referentes a dichas páginas se encontrarán en el directorio \textit{resources} siguiendo una estructura de paquetes análoga.
	\item \textbf{Paquete es.udc.acarballal.elmas.web.pages.components:} Contiene las clases que se utilizarán como plantillas para la representación de los diferentes tipos de página web en un navegador, recogiendo fun\-cio\-na\-li\-dad común para todas ellas.
	\item \textbf{Paquete es.udc.acarballal.elmas.web.pages.util:} Contiene las clases que representan los \textit{Application State Objects}(ASOs), los cuales son objetos que son accesibles a todas las páginas.
	\item \textbf{Paquete es.udc.acarballal.elmas.web.pages.services:} Contiene las clases referentes tanto al mantenimiento de la sesión y otros ASOs como al control de acceso a recursos.
\end{itemize}

\subsection{Paquete es.udc.acarballal.elmas.ffmpeg}

\begin{figure}[htp]
\centering
\includegraphics{imagenes/ffmpeg.jpg}
\caption{Estructura de paquetes del sistema de integración}
\label{model}
\end{figure}

\begin{itemize}
\item \textbf{es.udc.acarballal.ffmpeg.encoder:} Contiene las clases que representan los comandos de codificación necesarios para la integración con la aplicación de compresión de video FFMpeg.
\item \textbf{es.udc.acarballal.ffmpeg.encoder.codecs:} Contiene las clases que representan las capas de compresión para crear un modelo de compresión de video e imagenes necesarios por los diferentes portales.
\item \textbf{es.udc.acarballal.ffmpeg.encoder.configuration:} Contiene las clases necesarias para la recuperación de variables mediante \textit{JNDI} (Interfaz de Nombrado y Directorio Java).
\item \textbf{es.udc.acarballal.ffmpeg.process:} Contiene las clases que representan los procesos de compresión.
\item \textbf{es.udc.acarballal.ffmpeg.process.exceptions:} Contiene las clases que representan las excepciones que se pueden producir durante un proceso de compresión de video.
\item \textbf{es.udc.acarballal.ffmpeg.encoder.util:} Contiene las clases utilizadas para la creación de claves alfanuméricas y directorios aleatorios.

\end{itemize}

\section{Capa modelo}
\label{capamodelo}
\subsection{Almacenamiento persistente}
Para el almacenamiento persistente de datos se utilizará una base de datos relacional. El manejo de los datos se realizará mediante un mapeador objeto-relacional, Hibernate 3, de modo que se simplifica la programación de la capa de persistencia.
De este modo, mediante la utilización de un ORM, no se oculta el tipo de base de datos pero no se especifica la bases de datos concreta que se utiliza.
Esta elección nos aportará las siguientes ventajas:
\begin{itemize}
	\item Transparencia
	\item Api dual
	\item No requiere contenedor
	\item Modelo e implementación independientes
	\item Permite grandes consultas (HQL y/ó SQL)
	\item Optimiza el acceso a los datos
\end{itemize}

Para cada clase persistente tendremos por un lado el objeto de transferencia (\textit{Transfer Object}), que sería la clase que contiene los datos que sería necesario almacenar de forma persistente, y por otro su interfaz de acceso a datos o \textit{DAO}.

Para realizar la correspondencia entre los objetos del dominio y las relaciones de la base de datos se realizarán mediante anotaciones java.

\subsubsection{Modelo de dominio}
En este apartado se definen los conceptos del dominio utilizados. Para cada uno de los mismos se definirán tanto los detalles propios de cada uno como las relaciones que existen entre ellos.

\begin{figure}[htp]
\centering
\includegraphics*[width=15cm]{imagenes/persistencia.jpg}
\caption{Modelo de persistencia}
\label{dominio}
\end{figure}

\begin{itemize}
	\item \textbf{UserProfile (Perfil de usuario)} 
	
	Esta entidad representará la información referente a cada usuario re\-gis\-tra\-do dentro del sistema. Entre la información que se guarda se encuentran el nombre y apellidos del usuario (\textit{firstName} y \textit{lastName} respectivamente), el nombre de acceso o login (\textit{loginName}), contraseña (\textit{encryptedPassword}) y su email. Del mismo modo también se recogen los privilegios que tiene el usuario dentro del sistema, entre los cuales se encuentran:
		\subitem \textit{NONE}: el usuario no está registrado, no tiene permisos.
		\subitem \textit{VOTER}: el usuario está registrado y puede realizar votaciones semanales sobre videos obtenidos de forma aleatoria.
		\subitem \textit{COMPETITOR}: el usuario es un participante del concurso y como tal puede añadir gestionar videos propios asociados a su cuenta.
		\subitem \textit{ADMIN}: el usuario es un administrador del sistema, tiene permisos para realizar operaciones de administración como resolución de quejas o obtención de informes de los videos más votados.
		
Para esta entidad se implementa un DAO específico que da soporte para las operaciones CRUD básicas, además se implementa una operación de busqueda mediante HQL (Hibernate Query Language). 
\begin{figure}[htp]
\centering
\includegraphics*[width=12cm]{imagenes/PersistenciaUserProfile.jpg}
\caption{DAO de la entidad UserProfile}
\label{UserProfilePersistance}
\end{figure}
En concreto la operación de busqueda \textit{findByLoginName} se basa en la recuperación de un objeto UserProfile a partir del identificador único que lo distingue.
\newpage
	\item \textbf{Video} 
	
	Esta entidad representará la información referente a cada uno de los videos que son subidos por los usuarios y que entran a formar parte del concurso. Para cada video se recoge información como titulo (\textit{title}), comentario del usuario (\textit{comment}), fecha de subida (\textit{date}) y las direcciones donde se guardan los diferentes formatos de video e i\-ma\-ge\-nes asi como una pequeña captura. Los formatos que se guardan son FLV(alojado en \textit{flvVideo}), Real Player 3gp (\textit{rpVideo}), el archivo de video original subido por el propio usuario (\textit{original}) y la captura de pantalla en formato jpg (\textit{snapshot}).
\begin{figure}[htp]
\centering
\includegraphics*[width=12cm]{imagenes/PersistenciaVideo.jpg}
\caption{DAO de la entidad Video}
\label{VideoPersistance}
\end{figure}
	
El DAO correspondiente a esta entidad sigue el mismo formato que el anterior, implementando varios métodos de búsqueda necesarios para los diferentes casos de uso especificados con anterioridad. Se trata de búsquedas por titulo del video (\textit{findByTitle}), por usuario propietario del video (\textit{findByUser}) y búsqueda aleatoria de un video para realizar una votación (\textit{findRandomVotableVideo}). En el último caso, la elección del video a votar se realiza con varias restricciones, entre las que se encuentran:
\begin{enumerate}
	\item Un usuario no puede votar un video subido por él mismo.
	\item Cada semana sólo se pueden votar un total de 10 videos.
	\item No se puede votar varias veces por el mismo video.
	\item Los videos a votar son aleatorios.
\end{enumerate}
Para que todo esto se cumpla se utiliza el metodo \textit{findRandomVotableVideo}, en cuya implementación se ha optado por realizar búsquedas semialeatorias, dando prioridad siempre a los videos más recientes. Se utiliza una ventana de videos configurable mediante JNDI (esta ventana sirve para no tener que manejar cantidades ingentes de videos cada vez que deseemos realizar una votación) desde la cual si que se realizará la obtención del video a votar de manera aleatoria.
	\item \textbf{Vote} 
	
	En esta entidad se recogerán los votos semanales que irán realizando los usuarios sobre los videos aleatorios. Para cada voto se guardará una referencia tanto al video votado como al votante (\textit{video} y \textit{voter} respectivamente), la fecha de la votación y el voto concreto. 
\begin{figure}[htp]
\centering
\includegraphics*[width=15cm]{imagenes/PersistenciaVote.jpg}
\caption{DAO de la entidad Vote}
\label{VotePersistance}
\end{figure}

La votación (\textit{vote}) se realiza de manera cualitativa mediante rangos difusos, donde el usuario deberá elegir la calidad del video de entre las siguientes: muy malo, malo, normal, bueno y muy bueno. En cuanto a la persistencia de este dato en concreto dejamos que el propio mapeador lo almacene como un entero, el cual nos servirá posteriormente para realizar los rankings de los videos más votados.

El DAO de esta entidad implementa dos metodos de busqueda, correspondientes con la busqueda de los videos más votados entre dos fecha proporcionadas y la busqueda de los videos más votados de los que devolverá un numero concreto de videos (\textit{findMostVoted}, ambos análogos). Del mismo modo también se implementa otros dos metodos, uno sirve para conocer si un usuario ha votado por un determinado video (\textit{alreadyVoted}) y el otro para conocer el numero de votaciones restantes que puede realizar un usuario para la semana actual (\textit{votesRemaining}).	
\item \textbf{UserComment}
	
	La entidad UserComment almacenará los comentarios realizados hacia un determinado usuario, el cual, deberá ser un participante del concurso. Para cada comentario se recoge una relación al usuario que comenta (\textit{commentator}), una relación al usuario comentado (\textit{commen\-ted}), la fecha del comentario (\textit{date}) y el comentario propiamente dicho (\textit{comment}).
\begin{figure}[htp]
\centering
\includegraphics*[width=15cm]{imagenes/PersistenciaUserComment.jpg}
\caption{DAO de la entidad UserComment}
\label{UserCommentPersistance}
\end{figure}

Su DAO correspondiente implementa, además de las operaciones básicas CRUD, dos métodos de búsqueda de comentarios atendiendo a los usuarios relacionados con los mismos. De este modo, esos dos métodos son \textit{findCommentByCommentator} que realiza la búsqueda de todos los comentarios que ha realizado un determinado usuario, y \textit{findCommentByCommented} que busca todos los comentarios de los que un usuario es objeto.
	\item \textbf{VideoComment} 
	
	La entidad VideoComment almacerá los comentarios realizados hacia un determinado video, el cual, deberá existir en el sistema en todo momento. Para cada comentario se recoge una relación al usuario que comenta el video (\textit{commentator}), una referencia al video que se comenta (\textit{video}), el comentario propiamente dicho (\textit{comment}) y la fecha correspondiente a su publicación (\textit{date}).
\begin{figure}[htp]
\centering
\includegraphics*[width=15cm]{imagenes/PersistenciaVideoComment.jpg}
\caption{DAO de la entidad VideoComment}
\label{VideoCommentPersistance}
\end{figure}

El DAO correspondiente a esta entidad implementa a mayores dos métodos de búsqueda de comentarios. La primera de ellas es \textit{findVideoCommentsByUserId}, en la que devolverá todos los comentarios que un usuario ha hecho a algún video en algún momento, y \textit{findVideoCommentsByVideoId}, en la que se devolverán todos los comentarios que se han realizado sobre un determinado video.
	\item \textbf{UserCommentComplaint} 
	
	Esta entidad almacenará las quejas realizadas por cualquier usuario hacia un comentario hacia otro usuario, para que los administradores tengan constancia de ello. La información que se almacenará para cada queja consta de una referencia al usuario que se queja (\textit{complainer}), una referencia al comentario que es objeto de la queja (\textit{referenece}) y la fecha de la notificación de la misma (\textit{date}).
\begin{figure}[htp]
\centering
\includegraphics*[width=15cm]{imagenes/PersistenciaUserCommentComplaint.jpg}
\caption{DAO de la entidad UserCommentComplaint}
\label{UserCommentComplaintPersistance}
\end{figure}

El DAO correspondiente a esta entidad, además de las operaciones que comparte con el resto de DAOs comentados hasta el momento implementa tres nuevas operaciones. El método \textit{countUserCommentComplaints()} permite a los administradores obtener el número total de quejas sobre comentarios de usuarios que no han sido atendidas, \textit{findUserCommentComplaints} permite obtener un subconjunto de quejas, y por último, \textit{hasComplaint} permite conocer si un usuario ya ha rea\-li\-za\-do una queja al administrador sobre un determinado comentario de usuario.
	\item \textbf{VideoComplaint} 
	
	Esta entidad almacenará las quejas realizadas hacia un video por parte de cualquier usuario que no sea el propio poseedor del video. A partir de esta quejas los administradores tendrán constancia para hacer lo que estimen oportuno. La información que compone dicha queja es un referencia al usuario que ha realizado la queja (\textit{complainer}), el video que es objeto de la queja (\textit{reference}) y la fecha de notificación de la misma (\textit{date}).
\begin{figure}[htp]
\centering
\includegraphics*[width=15cm]{imagenes/PersistenciaVideoComplaint.jpg}
\caption{DAO de la entidad VideoComplaint}
\label{VideoComplaintPersistance}
\end{figure}

Su DAO correspondiente implementa las operaciones básicas CRUD junto con tres nuevos métodos. El método \textit{countVideoComplaints} permite a los administradores obtener el numero total de quejas sobre videos que no han sido atendidas hasta el momento, \textit{findVideoComplaints} permite obtener un subconjunto de quejas sobre videos, y \textit{hasComplaint} permite conocer si un usuario ya ha realizado una queja al administrador sobre un determinado video.
	\item \textbf{VideoCommentComplaint} 
	
	Esta entidad almacerá las quejas realizadas hacia un comentario de un video que ha realizado cualquier otro usuario del sistema. La información que compone dicha queja es una referencia al usuario que ha la realizado (\textit{complainer}), una referencia al comentario de video sobre la que se realiza la quejas (\textit{reference}) y la fecha de la notificación de la queja (\textit{date}).
\begin{figure}[htp]
\centering
\includegraphics*[width=15cm]{imagenes/PersistenciaVideoCommentComplaint.jpg}
\caption{DAO de la entidad VideoCommentComplaint}
\label{VideoCommentComplaintPersistance}
\end{figure}

Su DAO correspondiente implementa las operaciones básicas CRUD junto con tres nuevos métodos. El método \textit{countVideoCommentComplaints} permite a los administradores obtener el número total de quejas sobre comentarios de videos que no han sido atendidas hasta el momento, \textit{findVideoCommentComplaints} permite obtener un subconjunto de quejas sobre comentarios de videos, y \textit{hasComplaint} permite conocer si un usuario ya ha realizado una queja al administrador sobre un determinado comentario perteneciente a un video.
\item \textbf{Message}
	
	La entidad Message recogerá los mensajes enviados entre usuarios. Para cada mensaje se almacenarán el remitente del mensaje (\textit{sender}), el destinatario (\textit{receiver}) y en cuerpo de mensaje (\textit{text}).
\begin{figure}[t]
\centering
\includegraphics*[width=13cm]{imagenes/PersistenciaMessage.jpg}
\caption{DAO de la entidad Message}
\label{MessagePersistance}
\end{figure}

El DAO de esta entidad implementa dos métodos a mayores de las basicas ya citadas. Estos métodos son \textit{getInBox} que permitirá obtener un conjunto de mensajes que se encuentren relacionados con un usuario (el usuario sea el destinatario de esos mensajes), y \textit{inBoxTotal} que proporciona el número total de mensajes de los que un usuario es destinatario.

	En cuanto a la implementación real de sistema, los mensajes que pueden aparecer son únicamente de administracion, mensajes enviados de un usuario administrador a cualquier otro usuario. Como existe la posibilidad de ampliar la funcionalidad del sistema para que los usuarios se puedan mandar mensajes privados en el futuro se optó por utilizar un sistema generalizado en lugar de uno específico sólo para mensajes administrativos.
\item \textbf{Favourite}

	La entidad Favourite almacerá la relación de los videos favoritos de un usuarios dentro de los existentes dentro del sistema. Para cada favorito se almacena una referencia al usuario que lo ha elegido como tal y otra referencia hacia el video en cuestión.
\begin{figure}[htp]
\centering
\includegraphics*[width=13cm]{imagenes/PersistenciaFavourite.jpg}
\caption{DAO de la entidad Favourite}
\label{FavouritePersistance}
\end{figure}

El DAO correspondiente a Favourite, además de implementar las o\-pe\-ra\-cio\-nes básicas CRUD, recoge tres métodos a mayores, \textit{findFavourites} recuperará los videos favoritos de un determinado usuario, \textit{isFavourite} determinará si un determinado video se encuentra en la lista de favoritos de un usuario y \textit{removeFromFavourites} eliminará un video de la lista de favoritos de un usuario.
\end{itemize}
\newpage
\subsection{Fachadas y servicios}
La implementación de los casos de uso se ha realizado con Spring integrado con Hibernate 3. La combinación de Hibernate con Spring simplifica la implementación de los Objetos de Acceso a Datos (DAOs). Estas facilidades que proporciona Spring se deben a que utiliza el patrón DAO para encapsular los mecanismos de acceso a la base de datos de modo que se pueden implementar los DAOs basados en Hibernate sin tener en cuenta aspectos como las transacciones o la sesión.

El origen de Spring framework se remonta al framework llamado Interface 21 el cual fue utilizado en el libro \textit{Expert One to One J2EE Design and Development} escrito por Rod Johnson. Después se le cambio el nombre a Spring Framework. Desde la primera versión lanzada en Marzo del 2004 Spring framework es Open Source y el código fuente esta bajo la licencia Apache. Algunas de las razones para utilizar Spring framework son las siguientes:
\begin{itemize}
	\item Permite hacer un diseño por medio de interfaces de una manera sencilla.
	\item Implementa patrones de diseño.
	\item La documentación es extensa.
	\item Es un framework open source.
	\item Se comunica fácilmente con otros frameworks como lo son: Struts, \emph{Hibernate}, iBatis, \emph{Tapestry}, entre otros.
\end{itemize}

Con el objetivo de implementar las diferentes fachadas del sistema se ha optado por una implementación basada en la utilización de patrones muy usados para este fin, como son el caso del patrón \textit{Facade} y del patrón \textit{Business Delegate}. Mediante la combinación de estos dos patrones podemos crear una implementación sencilla en la que se oculte la implementación concreta de los métodos de negocio, teniendo en cuenta que el propio Spring implementa gran parte del codigo necesario gracias a su injección de dependencias.
Una vez dicho esto, veamos las diferentes fachadas en las que se divide el sistema. Se han creado tres fachadas concretas en las que se recogen todos los casos de uso comentados en el capítulo denominado \textit{\titleref{chapterAnalisis}} (página \pageref{chapterAnalisis}). 

\subsubsection{Fachada de usuarios (\textit{UserService})}
En la fachada de usuarios se definen todos aquellos casos de uso referentes a la información del usuario, mensajería entre usuarios y gestión de comentarios de usuarios, entre los que se encuentran los realizados por el propio usuario o en los que es el usuario el objeto de dichos comentarios.
\begin{figure}[htp]
\centering
\includegraphics*[width=9cm]{imagenes/InterfaceUserService.jpg}
\caption{Fachada de Usuarios}
\label{UserService}
\end{figure}
Además, dentro de la fachada se definen los siguientes \textit{custom transfer objects}:
\begin{itemize}
	\item \textbf{LoginResult: } Este clase se devuelve como resultado de la acción de \textit{login} dentro del sistema. Contiene información referente a identificador de usuario (\textit{userProfileId}), nombre de usuario (\textit{firstName}), contraseña (\textit{encryptedPassword}) y privilegios en el sistema (\textit{privileges}).
	\item \textbf{UserProfileDetails: } Esta clase contiene todas las propiedades específicas de usuario no necesarias para mantener la sesión. Es utilizada en la acción de registro de usuarios. Las propiedades que la componen son el nombre y apellidos reales del usuario (\textit{firstName} y \textit{lastName} respectivamente) y el email.
	\item \textbf{UserCommentBlock: } Almacena bloques de contenido referente a comentarios de usuarios o \textit{UserComment}.
	Cada uno de esos bloques se encapsula en un objeto de este tipo, el cual, además de contener un subconjunto de comentarios (\textit{userComments}), posee una propiedad para indicar si existen más bloques (\textit{existMoreUserComments}).
	\item \textbf{MessageBlock: } Esta clase encapsula bloques de contenido referente a mensajes entre usuarios (\textit{messages}). Del mismo modo que el ante\-rior, posee una propiedad para indicar si existen más mensajes (\textit{existMoreMessages}).
\end{itemize}
\begin{figure}[htp]
\centering
\includegraphics*[width=13cm]{imagenes/UserServiceCTO.jpg}
\caption{Custom Transfer Objects de UserService}
\label{UserServiceCTO}
\end{figure} 

\subsubsection{Fachada de videos (\textit{VideoService})}
En la fachada de videos se definen todos aquellos casos de uso referentes a la gestión de los videos, de las votaciones y los favoritos de cada usuario, asi como de las quejas que un usuario puede hacer en referencia tanto a videos como a comentarios de videos.
Dentro de la fachada se definen los siguientes \textit{custom transfer objects}:
\begin{figure}[htp]
\centering
\includegraphics[width=9cm]{imagenes/InterfaceVideoService.jpg}
\caption{Fachada de videos}
\label{VideoService}
\end{figure} 
\begin{itemize}
	\item \textbf{VideoBlock:} Almacena bloques de contenido referente a videos de usuarios.	Cada uno de esos bloques se encapsula en un objeto de este tipo, el cual, además de contener un subconjunto de videos, posee una propiedad para indicar si existen más bloques (\textit{existMoreVideos}).
	\item \textbf{VideoCommentBlock:} Esta clase encapsula bloques de contenido referente a comentarios de videos (\textit{VideoComments}). Del mismo modo que el anterior, posee una propiedad para indicar si existen más comentarios (\textit{existMoreVideoComments}).
\end{itemize}

\subsubsection{Fachada de administración (\textit{AdminService})}
En esta fachada se agrupan todos los casos de uso de administración. Entre ellos se encuentran la administración de quejas (videos, usuarios y comentarios) y la compresión de videos.
Dentro de la fachada se definen los siguientes \textit{custom transfer objects}:
\begin{figure}[htp]
\centering
\includegraphics[width=12cm]{imagenes/InterfaceAdminService.jpg}
\caption{Fachada de administración}
\label{AdminService}
\end{figure} 
\begin{itemize}
	\item \textbf{UserCommentComplaintBlock:} Almacena bloques de contenido re\-fe\-ren\-te a quejas sobre comentarios de usuarios.	Cada uno de esos bloques se encapsula en un objeto de este tipo, el cual, además de contener un subconjunto de quejas, posee una propiedad para indicar si existen más bloques (\textit{existMoreUserCommentComplaints}).
	\item \textbf{VideoCommentComplaintBlock:} Esta clase encapsula bloques de contenido re\-fe\-ren\-te a quejas sobre comentarios de videos (\textit{VideoCommentComplaint}). Del mismo modo que el anterior, posee una propiedad para indicar si existen más comentarios (\textit{existMoreVideoCommentComplaints}).
\end{itemize}

Como se mostró en la figura \ref{model} en la página \pageref{model}, la fachada de servicio posee dos paquetes denominados \textit{Thread} y \textit{Util}, que contienen las clases necesarias para la integración del sistema de codificación proporcionado por el servicio externo y los casos de usos que las manejan. Todo este tema se explicará con mas detalle en la sección \textit{\titleref{ExternalServices}} en la página \pageref{ExternalServices}.

\subsubsection{Ejemplo de configuración}
La configuración del sistema se basa en la declaración de \textit{beans}\footnote{Bean: componente software que tiene la particularidad de ser reutilizable}. Las posibles dependencias existentes entre los distintos beans se mantiene mediante la injección de dependencias basada en ``setters''. Veamos un ejemplo de configuración para la integración de Spring con Hibernate 3. En el fichero de configuración de Spring deberemos especificar varias cosas:
\begin{itemize}
	\item \textbf{DataSource:} Se necesita configurar una referencia a un DataSource. Spring proporciona, entre otras, las varias opciones para configurar un bean de tipo DataSource, definidos directamente sobre un driver JDBC o localizados via JNDI (este último es nuestro caso). Dentro del fichero de configuración se especificaría de la siguiente manera:
{\tt \scriptsize
\begin{verbatim}
	<bean id="dataSource" 
		class="org.springframework.jdbc.datasource.DriverManagerDataSource"
		p:driverClassName="com.mysql.jdbc.Driver"
		p:url="jdbc:mysql://localhost/elmas" p:username="elmas"
		p:password="elmas" />
\end{verbatim}
}
	\item \textbf{Sesión actual:} Los DAOs implementados con Hibernate necesitan un objeto de tipo \textit{org.hibernate.SesionFactory} del que obtener la sesión actual, el cual se indica de esta manera en el fichero de configuración:
{\tt \scriptsize
\begin{verbatim}
	<bean id="sessionFactory 
		class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"
		p:dataSource-ref="dataSource"
		p:configLocation="classpath:hibernate.cfg.xml"/>
\end{verbatim}
}
 Debemos tener en cuenta que el fichero \textit{hibernate.cfg.xml} es el fichero de configuración de \textit{Hibernate} y especifica los beans pertenecientes a los diferentes \textit{Transfer Object} pertenecientes a nuestras entidades persistentes.
 \item \textbf{Transacciones:} Spring proporciona una serie de gestores de transacciones que delegan la responsabilidad de la gestión de las transacciones a implementaciones específicas de la plataforma utilizada, configurandose de la siguiente manera:
{\tt \scriptsize
\begin{verbatim}
	<bean id="'transactionManager"
		class="org.springframework.orm.hibernate3ibernateTransactionManager"
  	p:sessionFactory-ref="sessionFactory" />
\end{verbatim}
}
	\item \textbf{DAOs:} Para cada uno de los DAOs implementados en el modelo se necesita declarar un bean que lo represente:
{\tt \scriptsize
\begin{verbatim}
	<bean id="userProfileDao"
  	class="es.udc.acarballal.elmas.model.userprofile.UserProfileDaoHibernate"
    p:sessionFactory-ref="sessionFactory" />
\end{verbatim}
}	
	\item \textbf{Fachadas:} Del mismo modo que ocurre con los DAOs, para cada fachada es necesario declarar su bean correspondente.
	{\tt \scriptsize
\begin{verbatim}
	<bean id="userService"
  	class="es.udc.acarballal.elmas.model.userservice.UserServiceImpl"
    p:userProfileDao-ref="userProfileDao"
    p:userCommentDao-ref="userCommentDao" 
    p:userCommentComplaintDao-ref="userCommentComplaintDao" 
    p:messageDao-ref="messageDao" />
\end{verbatim}
}	
\end{itemize}
\subsection{Integración con servicios externos}
\label{ExternalServices}

A la hora de realizar la compresión de los videos se ha optado por la utilización de un programa open source como FFMpeg, muy conocido en el campo, que es utilizado como base de otros codificadores multiplataforma, como es el caso de Mencoder. Al no existir en la actualidad ningun API multiproceso para la codificación de videos basado en FFMpeg, se ha creado un sistema completo que interactue con este programa, el cual debe encontrarse instalado en la maquina servidor.
El sistema se compone de 3 partes.
\begin{itemize}
	\item Codificadores o capas de codificación.
	\item Factoria de codificadores
	\item Sistema multiproceso
\end{itemize}

Veamos cada una de estas partes por separado:
\subsubsection{Codificadores o capas de codificación.}

Para realizar una compresión se necesitan especificar detalles en cuanto a calidad y tamaño de video, audio e imagenes (en el caso de que queramos obtener un \textit{snapshot}\footnote{Captura en formato de imagen a partir de un video multimedia} de un determinado video).
En el paquete \textit{codecs} se representan cada una de estas capas o \textit{layers}. En concreto tendremos una capa que se encargará especificar el tipo de compresión que se realizará sobre el video (\textit{VideoLayer}), una capa que hará lo mismo con el audio (\textit{AudioLayer}) y otra para el caso de la capturas de pantalla (\textit{SnapShotLayer}).
\begin{figure}[htp]
\centering
\includegraphics[width=12cm]{imagenes/ffmpeg_codecs.jpg}
\caption{Capa de codificación}
\label{codecs}
\end{figure} 
En cuanto a la implementación concreta se ha optado por la utilización del patrón \textit{Decodador}. Para la compresión de un determinado video se crea una capa de compresión basica denominada \textit{Codec}, a la cual se le van añadiendo capas en función del resultado que esperamos obtener. La elección de este patrón se basó en:
\begin{enumerate}
	\item Más flexibilidad que la herencia estática.
	\item Evita clases cargadas de funciones en la parte de arriba de la jerarquía.
	\item Cambiar la piel de un objeto en vez de sus tripas.
\end{enumerate}
Dentro de la jeraquía, la clase abstracta \textit{AbstractCodec}, implementa el método concreto necesario para la obtención de los comandos para realizar la codificación. Este método llamado \textit{generateCommand()} implementa a su vez el patrón \textit{Plantilla}, dejando que sean el codificador base y sus capas las que determinen exactamente el comando final, mediante los métodos \textit{generateVideoOptions}, \textit{generateAudioOptions} y \textit{generateImageOptions}.
La aplicación de este patrón se debe a que de esta manera somos capaces de controlar las extensiones de las subclases, para implementar las partes del algoritmo que son variables y ocultar de esta manera las partes del algoritmo que permanecen inalteradas.
Del mismo modo, dicha clase abstracta obtiene mediante JNDI una referencia al path en el cual se encuentra nuestra aplicación en el servidor, con el fin de conformar el comando.

\subsubsection{Factoria de codificadores}
En nuestro sistemas buscamos realmente poder realizar 3 tipos de compresiones concretas:
\begin{itemize}
	\item Compresión de un video a formato FLV\footnote{formato de archivo propietario usado para transmitir video sobre internet usando \textit{Adobe Flash Player}}.
	\item Compresión de un video a formato 3gp\footnote{formato de archivos usado por teléfonos móviles para almacenar información multimedia (audio y video)}.
	\item Obtención de una captura de imagen en formato JPEG\footnote{formato de archivo para la compresión de imágenes fotográficas} a partir de un video.
\end{itemize}
\begin{figure}[htp]
\centering
\includegraphics*[angle=90,width=12cm]{imagenes/ffmpeg_encoderFactory.jpg}
\caption{Factoría de codificación}
\label{encodeFactory}
\end{figure} 
Una vez que tenemos claro lo que necesitamos, implementamos siguiendo el patrón \textit{Factoría Abstracta} una clase que nos permita obtener un codificador completo para cada una de estas compresiones que buscamos. Mediante esta clase abstracta proporcionamos una biblioteca de codificadores presentando su interfaz, pero no su implementación. Dicha clase abstracta \textit{AbstractEncoderFactory} declara la interfaz para las operaciones que crean codificadores abstractos (métodos de fabricación). Por otra parte, la clase \textit{EncoderFactory} implementa los métodos de fabricación de codificadores
concretos, creando para cada método un codificador que satisfaga la creación de un video o imagen a partir del comando que proporciona.
Para la creación de los diferentes codificadores concretos se necesitan obtener determinados valores en tiempo de ejecución. Estos valores serán variables de la compresión como tiempo máximo del video resultante, calidad del audio y del video, tamaño de salida del video, bit rate\footnote{Tasa de bits (en inglés bit rate) define el número de bits que se transmiten por unidad de tiempo} del audio y del video, etc. Todas estas variables se obtienen mediante JNDI, facilitando de este modo que el administrador sea capaz de cambiarlas sin necesidad se detener el sistema.

\subsubsection{Sistema multiproceso}
El objetivo final de todo lo explicado hasta el momento es poder realizar la compresión de videos de forma paralela mediante una aplicación exterior. Para ello se ha creado un sistema completo que se encargue de realizarlo, asi como de mantener la integridad de los datos y videos de nuestro sistema y de nuestro contenedor multimedia.
Se han creado procesos concretos para cada video, que se encargan no solo de realizar la codificación, sino de eliminar los ficheros de log de dichas compresiones, de utilizar una captura de imagen por defecto si no se puede realizar correctamente la extracción de una perteneciente al video, de crear una referencia al video dentro del sistema, de mover los videos resultantes al contenedor multimedia, etc.
\begin{figure}[htp]
\centering
\includegraphics*[width=12cm]{imagenes/ffmpeg_process.jpg}
\caption{Procesos de codificación}
\label{process}
\end{figure} 

Antes de ver esos procesos, veamos como se realizan un proceso de compresión de manera individual: 
Cada proceso del sistema seguirá la interfaz \textit{IProcess}, la cual, a su vez, implementa el patron \textit{Comando}. Se ha elegido esta implementación basandonos en tres aspectos:
\begin{enumerate}
	\item Especificar, encolar, y ejecutar peticiones en diferentes momentos
	\item Soporte de Deshacer (\textit{Undo})
	\item Soporte de Logging
\end{enumerate}
En la figura \ref{process} podemos ver el diagrama explicativo de un proceso concreto. Cada proceso implementa los comandos \textit{execute()} y \textit{undo()}. Dentro de los procesos concretos, destacamos la utilización de fichero de log mediante el uso de la clase \textit{StreamGobbler}, la cual extiende a la clase Thread del API de Java. Esta clase crea un proceso en segundo plano que recoge la salida del programa externo, avisando al proceso concreto cuando existe algún error durante la codificación. 
\begin{figure}[htp]
\centering
\includegraphics[width=12cm]{imagenes/threads.jpg}
\caption{Threads de codificación}
\label{Threads}
\end{figure} 

La salida que recoge la clase StreamGobbler se va guardando en ficheros en formato \textit{log}. Cada proceso elegirá el formato de codificación del fichero de log (se recomienda ISO8859-1) mediante una variable obtenida mediante JNDI. Cuando la clase StreamGobbler reconoce un error avisará al proceso para que este pueda realizar la operación de undo(), necesaria sobre todo para que los ficheros de log no queden abiertos indefinidamente.
El interfaz IProcess no lo utilizan únicamente los procesos de compresión, sino que todos los procesos que toman partido durante un proceso inserción de un video dentro del sistema y del contenedor implementan dicho interfaz.
Cuando un usuario desea añadir un video se genera una sucesión de procesos relacionados entre si (\textit{UploadTask}), todos del tipo IProcess. Todos estos procesos seguirán el siguiente orden de ejecución:
\begin{enumerate}
	\item Codificación del video en formato FLV. La clase FlvEncoder (ver figura \ref{encodeFactory} pág. \pageref{encodeFactory}) se encargá de realizar dicha codificación.
	\item Codificación del video en formato 3gp. La clase RPEncoder (ver figura \ref{encodeFactory} pág. \pageref{encodeFactory}) se encargá de realizar dicha codificación.
	\item Mover la captura de pantalla por defecto a la carpeta de trabajo actual, realizado por la clase \textit{FileCopy}.
	\item Obtención de una captura del imagen del video en formato JPEG. La clase SnapShotEncoder (ver figura \ref{encodeFactory} pág. \pageref{encodeFactory}) se encargá de realizar dicha codificación.
	\item Eliminar los ficheros de log producidos durante los procesos de codificación. Realizado por la clase \textit{LogDelete}.
	\item Transferencia de los archivos creados (videos e imagen) junto con el archivo original a su correspondiente emplazamiento dentro del contenedor multimedia, realizado por la clase \textit{MoveTempFolder}.
	\item Inserción de una referencia del video dentro del sistema, realizado por la clase \textit{AcceptVideo}.
	\item Confirmar al usuario que su video se ha subido correctamente, o en caso contrario, comunicarle el porqué. Realizado por la clase \textit{ConfirmationMessage}.
\end{enumerate}

Cada una de estas tareas o \textit{UploadTask} generadas por cada usuario son administradas mediante una centralita de tareas denominada \textit{TaskCentral}. Será esta centralita la cual gestione la ejecución de cada una de las tareas (y subprocesos que la componen). Dentro del diseño de TaskCentral se ha utilizado el patrón Singleton por dos razones concretas:
\begin{enumerate}
  \item Para garantizar que existe unicamente una instancia en el servidor.
	\item Para tener acceso controlado a la única instancia.
\end{enumerate}
Internamente TaskCentral se compone de un numero dinámico de hilos de flujo o \textit{TaskList} (vease figura \ref{procesos} en página \pageref{procesos}), que encapsulan un conjunto de procesos de ejecución en orden de entrada, es decir, sin prioridad. Este conjunto de hilos sigue el principio de procesamiento paralelo que vamos buscando, ya que cada hilo de flujo es controlado únicamente por TaskCentral, la cual va insertando procesos (UploadTask) para que sea el propio hilo el que los ejecute en orden de llegada. Se utiliza una variable obtenida mediante JNDI para determinar el número de procesos paralelos máximos que puede realizar la máquina, lo cual nos indicará el número de hilos de procesamiento que podemos tener. Se recomienda que se utilice la siguiente regla a la hora de especificar el número de procesamiento paralelos en caso de que no se tengan conocimientos específicos del sistema.
\begin{displaymath}
\mathbf{N} = n - 1 \left\{ \begin{array}{ll}
\mathbf{N} & \textrm{número de procesamientos paralelos máximos}\\
n & \textrm{número de procesadores del servidor}
\end{array} \right.
\end{displaymath}

\begin{figure}[htp]
\centering
\includegraphics[width=12cm]{imagenes/Procesos.jpg}
\caption{Ejemplo de procesamiento}
\label{procesos}
\end{figure} 

La razón se basa principalmente en mantener el servidor con el menor estrés posible. Utilizando n-1 procesadores de la máquina nos aseguramos que al menos un procesador en todo momento pueda atender a las peticiones que reciba (en este caso nos referimos a peticiones de ambos portales), de modo que cuando sea necesario tener varios hilos de procesamiento en ejecución al mismo tiempo se pueda seguir dando soporte a la aplicación web.

\subsection{Configuración}
Repetidas veces a lo largo de este capítulo se ha comentado que el sistema obtiene el valor de algunas variables en tiempo de ejecución mediante JNDI, de modo que se pueda cambiar la configuración del sistema sin tener que detener la aplicación web. Dentro del fichero de configuración de Tapestry se tendrán que especificar los valores que se desean para dichas variables. A continuación se muestra un ejemplo de como quedaría configurada nuestra aplicación con los valores que se proporcionan por defecto:
{\tt \scriptsize
\begin{verbatim}
<env-entry>
	<env-entry-name>unavailable/snapshot</env-entry-name>
 	<env-entry-value>C:\carpeta_apache\container\unavailable.jpg</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>
    
<env-entry>
 	<env-entry-name>temporal/directory</env-entry-name>
 	<env-entry-value>C:\\carpeta_apache\\temporal\\</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>
  	
<env-entry>
 	<env-entry-name>ffmpeg/application/path</env-entry-name>
 	<env-entry-value>ffmpeg.exe</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>
  	
<env-entry>
 	<env-entry-name>ffmpeg/maxTime</env-entry-name>
 	<env-entry-value>90</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>
  	
<env-entry>
 	<env-entry-name>ffmpeg/flv/extension</env-entry-name>
 	<env-entry-value>flv</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>
  	
<env-entry>
 	<env-entry-name>ffmpeg/flv/videoformat</env-entry-name>
 	<env-entry-value>flv</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>
  	
<env-entry>
 	<env-entry-name>ffmpeg/flv/videoframerate</env-entry-name>
 	<env-entry-value>25</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>

<env-entry>
	<env-entry-name>ffmpeg/flv/videosize</env-entry-name>
 	<env-entry-value>vga</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>

<!--
<env-entry>																							
	<env-entry-name>ffmpeg/flv/audiocodec</env-entry-name>
	<env-entry-value>libfaac</env-entry-value>						
	<env-entry-type>java.lang.String</env-entry-type>			
</env-entry>																							
-->

<env-entry>
 	<env-entry-name>ffmpeg/flv/audiobitrate</env-entry-name>
 	<env-entry-value>64</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>

<env-entry>
 	<env-entry-name>ffmpeg/flv/audiochannels</env-entry-name>
 	<env-entry-value>1</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>
  	
<env-entry>
 	<env-entry-name>ffmpeg/flv/audiofrecuence</env-entry-name>
 	<env-entry-value>44100</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>

<env-entry>
 	<env-entry-name>ffmpeg/rplayer/extension</env-entry-name>
 	<env-entry-value>3gp</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>
  	
<!--
<env-entry>																										
<env-entry-name>ffmpeg/rplayer/videoformat</env-entry-name>		
<env-entry-value>3gp</env-entry-value>												
<env-entry-type>java.lang.String</env-entry-type>						
</env-entry>
-->

<env-entry>
 	<env-entry-name>ffmpeg/rplayer/videoframerate</env-entry-name>
 	<env-entry-value>25</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>

<env-entry>
 	<env-entry-name>ffmpeg/rplayer/videosize</env-entry-name>
 	<env-entry-value>sqcif</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>

<env-entry>
 	<env-entry-name>ffmpeg/rplayer/audiocodec</env-entry-name>
 	<env-entry-value>libfaac</env-entry-value>
	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>

<env-entry>
 	<env-entry-name>ffmpeg/rplayer/audiobitrate</env-entry-name>
 	<env-entry-value>64</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>
  	
<env-entry>
 	<env-entry-name>ffmpeg/rplayer/audiochannels</env-entry-name>
 	<env-entry-value>1</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>

<env-entry>
 	<env-entry-name>ffmpeg/rplayer/audiofrecuence</env-entry-name>
 	<env-entry-value>44100</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>

<env-entry>
 	<env-entry-name>ffmpeg/image/extension</env-entry-name>
 	<env-entry-value>jpg</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>
  	
<env-entry>
 	<env-entry-name>ffmpeg/image/time</env-entry-name>
 	<env-entry-value>10</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>

<env-entry>
 	<env-entry-name>ffmpeg/image/start</env-entry-name>
 	<env-entry-value>10</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>

<env-entry>
 	<env-entry-name>ffmpeg/image/frames</env-entry-name>
 	<env-entry-value>1</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>
  	
<env-entry>
 	<env-entry-name>portal/url</env-entry-name>
 	<env-entry-value>http://adriancarballal.dynalias.com/videos_webService/</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>
  	
<env-entry>
 	<env-entry-name>container/directory</env-entry-name>
 	<env-entry-value>C:\\carpeta_apache\\container</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>
  	
<env-entry>
 	<env-entry-name>container/url</env-entry-name>
 	<env-entry-value>http://adriancarballal.dynalias.com/container/</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>  
  	
<env-entry>
 	<env-entry-name>max/parallels/processes</env-entry-name>
 	<env-entry-value>1</env-entry-value>
 	<env-entry-type>java.lang.String</env-entry-type>
</env-entry>

\end{verbatim}
}
\section{Capa presentación}
Como se comentó con anterioridad la aplicación sigue el patrón arquitectónico \textit{Modelo Vista Controlador} (MVC). 
\begin{figure}[htp]
\centering
\includegraphics[width=9cm]{imagenes/mvc.jpg}
\caption{Modelo - Vista - Controlador}
\label{MVCFlow}
\end{figure} 
En nuestro caso, las clases inferiores componen el modelo (explicado en la sección anterior), mientras que esta capa representa a la vista y al controlador.
Se eligió el framework web \textit{Tapestry 5}, en su versión 5.0.18 Stable (Junio 2008). Este framework es totalmente orientado a objetos, donde cada pantalla de la aplicación se compondrá por un lado del aspecto visual, en HTML plano (ficheros \textit{tml}), y por otro por los componentes que implementan las acciones asociadas a dicha pantalla o controladores.

En Tapestry 5 una aplicación web se compone de páginas. El controlador de cada página está compuesto por diferentes componentes, los cuales a su vez pueden estár compuestos por otros subcomponentes (véase figura \ref{componentes} en página \pageref{componentes}).
\begin{figure}[htp]
\centering
\includegraphics[width=9cm]{imagenes/componentes.jpg}
\caption{Modelo de aplicación web en Tapestry }
\label{componentes}
\end{figure} 

Es por esto que Tapestry es un framework orientado a componentes, ya que todo se ve como tal. Cada componente en concreto puede estar asociado a diferentes cosas: plantillas, mensajes internacionalizados, etc... (véase figura \ref{ElementosComponentes} en página \pageref{ElementosComponentes}).
\begin{figure}[htp]
\centering
\includegraphics[width=9cm]{imagenes/componenteElementos.jpg}
\caption{Elementos asociados con componentes en Tapestry }
\label{ElementosComponentes}
\end{figure} 

\subsection{Capa controlador}
El controlador será el encargado de transmitir los eventos que se producen en la vista a la capa modelo y al mismo tiempo recuperar los datos del modelo para mostrarlos en la vista, manteniendo por otra parte ambas capas desacopladas.
En el caso de Tapestry, es el propio framework el que se encarga de gestionar las peticiones, estando esta implementación oculta para el desarrollador. En cambio, si que se tendrá que definir lo siguiente:
\begin{enumerate}
	\item Los componentes comunes para todas las páginas. En nuestro caso, todas las paginas de la aplicación derivan de un modelo o plantilla, dependiendo de si se tratan de páginas optimizadas para dispositivos móviles o para páginas visualizables con cualquier navegador convencional.
	\item Los controladores para cada una de las distintas páginas que componen la aplicación. Cada pagina poseerá un controlador propio que interacturá directamente con el modelo y será capaz de posibilitar la navegación hacia otras páginas de la aplicación.
	\item Los ASO's o \textit{Application State Objects}, objetos que estén accesibles a todas las páginas. Estos objetos contendrá información que será necesaria dentro de la sesión de un usuario. En nuestra aplicación existen dos, uno guarda la información referente al usuario registrado que maneja la sesión, y en la otra se guarda información referente a la navegación entre páginas.
	\item Servicios de gestión de peticiones y mantenimiento de la sesión. Tapestry posee su propio gestor de peticiones que implementa el patrón \textit{Cadena de Responsabilidad} con comandos para analizar peticiones y procesarlas de forma adecuada.
Se nos permite establecer filtros dentro de la cadena de modo que podamos establecer un control sobre el acceso a las diferentes páginas.
\end{enumerate}
\begin{figure}[htp]
\centering
\includegraphics[width=9cm]{imagenes/IoC.jpg}
\caption{Tapestry IoC}
\label{IoC}
\end{figure} 
El funcionamiento normal del sistema se basa en que sean las propias páginas las que establezcan el flujo de redireccionamiento. En nuestro caso, mediante la creación de un filtro de control, somos capaces de establecer controles de acceso a determinadas páginas en función de los privilegios que un usuario tiene. El sistema seguiría el siguiente flujo:
\begin{enumerate}
	\item Una página se dispone a realizar el cambio a otra página por medio de una petición al servidor.
	\item Dentro del servidor el filtro de control determina si el usuario asociado a la sesión posee privilegios suficientes para que la petición se lleve a cabo con exito.
	\item Si el usuario posee privilegios suficientes se le redirige a la página que se solicitaba.
	\item Si el usuario no posee los privilegios necesarios, se le redirige a otra página.
\end{enumerate}
La implementación de lo comentado hasta este punto se compone de:
\begin{itemize}
	\item \textbf{AppModule:} Inyecta los dos servicios como argumentos del método, para poder añadirlos a la cadena de comandos que utilizará Tapestry. Estos servicios son para mantener la información de sesión y el filtro de redireccionamiento comentado anteriormente.
	
	\item \textbf{SessionDispatcher} Servicio \textit{Dispacher} que permite mantener la información de usuario dentro de la sesion. Está directamente relacionado con el ASO \textit{UserSession}.

	\item \textbf{AuthenticationDispatcher} Servicio \textit{Dispacher} que permite establecer un filtro para controlar si el usuario de la sesión tiene permisos suficientes para acceder a determinados recursos.
	
	\item \textbf{AuthenticationPolicy} Anotación para especificar el nivel de acceso sobre cada página de la aplicación sobre la que se desee establecer restricciones. Valor por defecto \textit{ALL\_USERS}.
	
	\item \textbf{AuthenticationPolicyType} Tipo enumerado que especifica las diferentes políticas de redireccionamiento dentro del sistema. Valores posibles: 
\begin{itemize}
	\item ALL\_USERS
	\item AUTHENTICATED\_USERS
	\item NON\_AUTHENTICATED\_USERS
	\item ADMINISTRATORS
	\item PARTICIPANTS
\end{itemize}
\end{itemize}

Para que Tapestry utilice el filtro debemos de especificarselo en su fichero de configuración de la siguiente manera:
{\tt \scriptsize
\begin{verbatim}
<filter>
 	<filter-name>app</filter-name>
 	<filter-class>org.apache.tapestry5.spring.TapestrySpringFilter</filter-class>
</filter>
\end{verbatim}
}	
\subsection{Capa vista}
Cada página tiene asociada una plantilla y una clase Java. La clase Java será el controlador de dicha página (como se ha visto en el apartado anterior) y la plantilla será la vista que se le proporciona.

A parte de los diferentes controladores que existen para cada página, en realidad se necesita el diseño concreto de la misma o plantilla (Tapestry las llama \textit{markups}). Gracias a Tapestry tanto controlador como diseño de página están totalmente desacoplados, lo cual conlleva una ventaja a la hora del desarrollo, permitiendo que un diseñador y un programador trabajen de forma paralela sin que el diseñador tenga conocimiento específico sobre el código del controlador asociado.

Una plantilla es un documento XML que permite generar un markup. En el caso de una aplicacion Web, el markup es normalmente
HTML o XHTML, pero tambien podria ser, por ejemplo, XML. Tiene extensión .tml (\textit{Tapestry Markup Language}). Tanto el controlador como la plantilla deben tener el mismo nombre.

Todas las páginas, tanto las pertenecientes al portal web como las del portal optimizado para móviles siguen un diseño específico a partir de una plantilla general de diseño o \textit{layout}. Este layout define la estructura y la disposición de los elementos que componen nuestro diseño. 

\newpage
\textbf{Vista del portal web}

Este es el layout correspondiente al portal web:
\begin{figure}[htp]
\centering
\includegraphics[width=12cm]{imagenes/layout.png}
\caption{Disposición de layout para el portal web}
\label{layout}
\end{figure} 
\begin{itemize}
	\item \textbf{Título, logo y pie de página}
	\item \textbf{Lista de enlaces:} Compuesto por todos los enlaces accesibles por los usuarios. Solo cambia en el caso de que el usuario registrado sea administrador, en cuyo caso el número de enlaces aumenta para que pueda realizar sus labores administrativas.
	\item \textbf{Barra de búsqueda:} Formada únicamente por un componente del tipo TextArea, que permitirá realizar la búsqueda de videos a partir de las palabras claves que se le propongan.
	\item \textbf{Lista de más votados:} Lista dinámica con los videos más votados por los usuarios. La lista se actualiza en el caso de que se tenga que realizar un refresco completo de la misma.
	\item \textbf{Contenido:} Es la parte cambiante de la plantilla. En muchos casos sólo se tiene que realizar un refresco sobre determinados datos contenidos en esta parte, por lo que el resto de la estructura permanece inalterable. Esto se debe a que Tapestry permite la utilización de elementos basados en Ajax \footnote{acrónimo de \textit{Asynchronous JavaScript And XML}} de manera nativa.
\end{itemize}

\textbf{Vista del portal optimizado para dispositivos móviles}

Este es el layout correspondiente al otro portal de la aplicación:
\begin{figure}[htp]
\centering
\includegraphics[width=5cm]{imagenes/layoutMobile.png}
\caption{Disposición de layout para el portal web}
\label{layout}
\end{figure} 
\begin{itemize}
	\item \textbf{Título}
	\item \textbf{Barra de acceso:} Esta barra posee dos estados, no hay ningun usuario registrado en la sesión y proporciona un link a la página de acceso, y el otro es cuando existe un usuario y nos permite cerrar la sesión actual.
	\item \textbf{Contenido:} Es la parte cambiante de la plantilla. En muchos casos sólo se tiene que realizar un refresco sobre determinados datos contenidos en esta parte, por lo que el resto de la estructura permanece inalterable. Esto se debe a que Tapestry permite la utilización de elementos basados en Ajax de manera nativa.
\end{itemize}


\textbf{Implementación de la vista}

Dentro de nuestra aplicación la estructura de la implementación de la vista corresponderá con la figura.
\begin{figure}[h]
\centering
\includegraphics[width=12cm]{imagenes/estructuraVista.png}
\caption{Estructura Capa Vista}
\label{estructuraVista}
\end{figure} 
Como se explicó anteriormente por cada página existirá un controlador y una plantilla. Ambas tendrán el mismo nombre aunque se encuentren en carpetas diferentes. Como se observa en la figura, una página de ejemplo denominada \textit{ShowVideos} tendrá asociado un controlador que se encontrará en la carpeta \textit{java} (ShowVideos.java) y un markup en la carpeta \textit{resources} (ShowVideos.tml). En concreto, ambos archivos tienen asociados otra clase de archivos del tipo \textit{properties}. Estos archivos contienen los mensajes internacionalizados visibles en dicha página, encontrandose en la misma localización que el markup de la página. Debemos tener en cuenta, que pueden existir mensajes internacionalizados que sean comunes a todas las páginas de la aplicación, y estos se encontrarán a la altura del fichero de configuración de la aplicación, en la ruta \textit{webapp/WEB-INF}.



